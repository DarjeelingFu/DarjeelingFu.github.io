---
layout: post
title: "递归算法思想小总结"
date: 2020-10-21 20:49:10 +0800
summary: 我对递归的认识
outerCover: https://pic2.zhimg.com/80/b10b80733bd3512d265c69f68f0c6d4c_720w.jpg?source=1940ef5c
innerCover: 
categories: 
tags: [算法]
---

## 我对递归的理解

在代码角度上，递归是指函数对自身的调用；在数学领域中，可通过递归解决的问题往往有自己的递推公式，这与“函数调用自身”在理解上和形式上都十分相似；现实问题中，递归往往是对问题的拆解，即该问题可以通过将大问题化小，小问题化了来解决，相比上面两个层面，在这一层面上，递归体现了它 十分关键的一个特点，即存在递归的终点。这个“终点”往往是整个文字的出发点，而且十分容易解决，就像`1! == 1`一样。

在实际写递归代码时，可以按与上述角度相反的顺序来思考，也即，首先，将问题拆分。欲做到这一点，往往按照“由顶向下”的思路分析，即，要实现最终问题，前一步要先实现什么，这样一来，“前一步”就会不停的展开下去，再稍加总结，发现共同规律，就会得到上述第二个角度提到的递推公式`f(n) = G(n - k)`，其中`G(x)`为一系列`f(x)`和其他已知值的运算，`x`取`n`减去一正整数`k`或`x`就是该递归过程的一个终点

通常，递推公式与最终代码的形式十分相似，但递推公式相比最终代码，少了十分重要的一部分。递归公式是数学的，它仅仅反映关系，而对于递归的终点不会提及，就好比行列式的递归定义不会告知“递归到二阶（或者直接到一阶）行列式时问题即可简单解决”，而程序代码负责得出最终的结果（最具代表性的就是一句`return`语句），因而代码中必须含有判断递归终点的一部分，这部分是代码与纯数学递归公式的一个显著区别。

这样一来，参考前面提到的递归公式，一个使用递归思想解决问题的函数大概长这个样子：

```python
def solve(n):
    # 先判断一下递归终点，避免一直归下去
    if expression:
        return value
    
    # 没到终点，就按照递归公式接着归下去(这里递归公式仅为示例)
    return values * solve(n - 1)

```

## 记录一些递归的例子（长期更新）

* 上楼梯问题，描述大概如下

> 一个人爬楼梯，一次最多只能爬3级，问爬上15级楼梯一共有多少种方法？

要上n级，可以从`n - 1`，`n - 2`，`n - 3`上，递推公式get

递归终点：

| 终点可能的情况         | 上一级 | 上两级 | 上三级 |
| ---------------------- | ------ | ------ | ------ |
| 可能的方法数（返回值） | 1      | 2      | 4      |

代码：

```python
def solve(n):
    if n == 1:
        return 1
    if n == 2:
        return 2
    if n == 3:
        return 4
    
    return solve(n - 1) + solve(n - 2) + solve(n - 3)
    # 为什么老把我认成是yaml的代码···

```



实际递归过程中多个相同的`solve(n)`被运算了，降低了算法效率，优化方法很多，暂略。

